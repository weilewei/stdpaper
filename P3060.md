---
breaks: false
---

<style type="text/css">
ins { background-color: #CCFFCC }
s { background-color: #FFCACA }
blockquote { color: inherit !important }
table.no-alt tr:nth-child(2n) { background-color: inherit }
.godbolt {
    background-size: contain;
    background-repeat: no-repeat;
    background-position-y: center;
    background-image: url("https://godbolt.org/favicon.ico?v=1")
}
</style>

<table><tbody>
<tr><th>Doc. no.:</th>    <td>P3060R0</td></tr>
<tr><th>Date:</th>        <td>2023-11-22</td></tr>
<tr><th>Audience:</th>    <td>LEWG</td></tr>
<tr><th>Reply-to:</th>    <td>Weile Wei &lt;weilewei09@gmail.com&gt;</td></tr>
</tbody></table>

# Add std::views::upto(n)

[TOC]

## Abstract
This proposal suggests adding `std::views::upto(n)` to the C++ Standard Library as a range adaptor that generates a sequence of integers from `0` to `n-1`.

## Motivation
Currently, `views::iota(0, ranges::size(rng))` does not compile due to mismatched types (see discussion 1 in [Background](#Background)). Then, users need to write `iota(range_size_t<decltype(rng)>{}, ranges::size(rng));`, which is not straightforward and cumbersome. An example illustrating this issue is available at {[<span class="godbolt">&#x2001;</span>q6a145hfb](https://godbolt.org/z/q6a145hfb)|Compiler&puncsp;Explorer}:

<table class="no-alt"><tbody>
<tr><th>

before

</th><td>

```cpp
std::vector rng(5, 0);
// auto res1 = views::iota(0, ranges::size(rng)); // does not compile
auto res2 = ranges::views::iota(ranges::range_size_t<decltype(rng)>{}, ranges::size(rng));
std::print("{}", res2); // [0, 1, 2, 3, 4]
```

<tr><th>

==after==

</th>
<td>

```cpp
std::vector rng(5, 0);
std::print("{}", views::upto(ranges::size(rng))); // [0, 1, 2, 3, 4]
```

</td></tr>
</tbody></table>


`std::views::upto(n)` eases this pattern by providing a straightforward and type-safe method to generate integer sequences, improving code readability and minimizing repetitive code.


## Implementation and Usage
Implementation details:
```cpp
namespace std::views {
    inline constexpr auto upto = [] <std::integral I> (I n) {
        return std::views::iota(I{}, n);
    };
}
```
Usage:
```cpp
int main() {
    std::vector rng(5, 0);
    std::print("{}", views::upto(ranges::size(rng))); // [0, 1, 2, 3, 4]
}
```

The implementation is confirmed to work with clang version 16.0.0+, gcc version 11.1+, and msvc v19.32+: {[<span class="godbolt">&#x2001;</span>xs7fWsGx6](https://godbolt.org/z/xs7fWsGx6)|Compiler&puncsp;Explorer}

## Background
Two preceding proposals have provided fundation for `std::views::upto(n)`:

1. *P2214R2: A Plan for C++26 Ranges*[^rangesplan] highlights the issue with `views::iota(0, r.size())` not compiling due to mismatched types. `std::ranges::views::iota` requires both arguments to be of the same type, or at least commonly comparable. This becomes problematic when comparing `int` (often 32-bit) with `std::size_t` (often 64-bit), which is usually wider on 64-bit systems. An example illustrating this issue is available at {[<span class="godbolt">&#x2001;</span>q6a145hfb](https://godbolt.org/z/q6a145hfb)|Compiler&puncsp;Explorer}.
```cpp
std::vector rng(5, 0);
auto res1 = iota(0, ranges::size(rng)); // does not compile
```
2. *P1894R0: Proposal of std::upto, std::indices and std::enumerate*[^stdupto] proposed an implementation (see below) that our proposal refines. Our approach offers a more intuitive and consistent interface, fitting seamlessly with existing standard library components without adding complexity.
```cpp
// std::upto implementation example
// P1894R0: Proposal of std::upto, std::indices and std::enumerate
namespace std {
    template<typename Int>
    constexpr auto upto(Int&& i) noexcept {
        return std::ranges::iota_view{Int(),std::forward<Int>(i)};
    }
}
```

## Technical Decisions
1. Limiting to `std::integral`: This constraint ensures functionality is restricted to integral types, yielding predictable behavior and avoiding the pitfalls of generic types. A more relaxed constraint to `std::default_initializable` and `std::incrementable` would allow iterators to compile but might introduce undefined behavior. An example illustrating this issue is available at {[<span class="godbolt">&#x2001;</span>nr9bEoebT](https://godbolt.org/z/nr9bEoebT)|Compiler&puncsp;Explorer}:
```cpp
namespace std::views {
    // a more relaxed design pattern, compiled but UB
    inline constexpr auto upto2 = 
        []<typename T> (T n)
            requires std::default_initializable<T> && std::incrementable<T>
        {
            return std::views::iota(T{}, n);
        };
}

int main() {
    int myint = 5;
    int* ptr = &myint;
    
    // !!!compiled but undefined behavior!!!
    auto up_to_five = std::ranges::views::upto2(CustomIterator{ptr});
    for (auto i : up_to_five) {
        std::cout << *i << ' ';
    }

    return 0;
}
```

2. Lambda-based Approach: Employing a lambda is consistent with the established range adaptor patterns. Moreoever, the `constexpr` specifier on the lambda ensures that the lambda object is a constant expression. 

3. Leveraging Existing `iota_view` Instead of Creating a New `upto_view`: Introducing `upto_view` would mean adding a component similar to what already exists, causing confusion and maintainability issues for users. By leveraging `iota_view`, we simplify the implementation and reuse of what the current C++ Standard Library offers. Additionally, any future optimizations to `iota_view` will automatically benefit `std::views::upto`. Therefore, by extending `iota_view`, `std::views::upto` becomes more maintainable, efficient, and simple.
## Wording
This wording is relative to [N4964](https://open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4964.pdf).

### Header <ranges> synopsis [[ranges.syn]](http://www.eelis.net/c++draft/ranges.syn)
Insert a new item in the `std::ranges` namespace:
```cpp
namespace std::views {
    inline constexpr auto upto = [] <std::integral I> (I n) {
        return std::views::iota(I{}, n);
    };
}
```
### New subsection under [[range.iota.view]](http://www.eelis.net/c++draft/range.iota.view)
Add a new subsection to describe `std::views::upto`:

26.6.4.2.1 upto function [range.upto]

-1- The name `upto` denotes a range adaptor object ([[range.adaptor.object]](http://www.eelis.net/c++draft/range.adaptor.object)). The expression `std::views::upto(n)` is expression-equivalent to `std::views::iota(I{}, n)` where `I` is the type of `n`.

-2- Constraints: The type `I` shall satisfy the `std::integral` concept.

-3- Returns: A view of the integers in the range [0, n).

-4- Complexity: Constant time.

-5- Remarks: This function template shall not participate in overload resolution unless `std::integral<I>` is true.

## References

[^rangesplan]: P2214R2 _A Plan for C++26 Ranges._
https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2760r0.html

[^stdupto]: P1894R0 _Proposal of std::upto, std::indices and std::enumerate._
https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1894r0.pdf
